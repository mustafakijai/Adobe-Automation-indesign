/**************************************************************
 * MapLayer_AutoStyler_FORCE_v3.jsx
 * Author: ChatGPT for Mr Khan — 2025
 * Illustrator 2019–2025 (ExtendScript)
 *
 * • Scans ENTIRE document (layers, sublayers, clip groups, groups).
 * • For each item, finds the NEAREST ancestor that is a Layer
 *   (the sublayer name you see, e.g., "Road/Highway/0") and matches rules.
 * • Auto-unlocks & reveals the whole ancestor chain before styling.
 * • Strong, vivid colors so changes are obvious. Visible fallback.
 **************************************************************/
#target illustrator
(function(){
  if (app.documents.length===0){ alert("Open a document first."); return; }
  var doc = app.activeDocument;

  // ---------- helpers ----------
  function rgb(R,G,B){ var c=new RGBColor(); c.red=R; c.green=G; c.blue=B; return c; }

  var C = {
    white: rgb(255,255,255), noir: rgb(25,25,25),
    // vivid lines
    fwy: rgb(255,0,152), hwy: rgb(255,106,0), major: rgb(255,230,0),
    minor: rgb(0,229,255), local: rgb(120,120,120), tunnel: rgb(160,160,160),
    // water/areas
    waterL: rgb(0,168,255), waterA: rgb(191,232,255), bathy: rgb(160,205,245),
    rail: rgb(138,43,226), ferry: rgb(0,200,180), bndry: rgb(255,45,45),
    parkA: rgb(67,255,100), forest: rgb(0,200,83), land: rgb(245,242,235),
    poi: rgb(41,98,255), medical: rgb(255,59,59), education: rgb(123,97,255),
    retail: rgb(255,127,0), landmark: rgb(255,0,255), emergency: rgb(255,23,68),
    cemetery: rgb(126,140,141), golf: rgb(46,204,113), industry: rgb(255,179,0),
    transport: rgb(41,98,255), military: rgb(109,76,65)
  };

  var FALLBACK_FONTS=["SourceSansPro-Regular","ArialMT","Helvetica","MyriadPro-Regular"];
  function findTextFont(family,style){
    try{
      var i,tf;
      if (family||style){
        for(i=0;i<app.textFonts.length;i++){tf=app.textFonts[i]; if((!family||tf.family===family)&&(!style||tf.style===style)) return tf;}
        if (family){ for(i=0;i<app.textFonts.length;i++){tf=app.textFonts[i]; if(tf.family===family) return tf;} }
      }
      for(i=0;i<FALLBACK_FONTS.length;i++){ try{ return app.textFonts.getByName(FALLBACK_FONTS[i]); }catch(e){} }
    }catch(e){}
    return app.textFonts.length ? app.textFonts[0] : null;
  }

  // ---------- rules (target nearest Layer name) ----------
  // {name, target: "text"|"path", layerPattern: /.../i, style:{...}}
  var RULES = [
    // --- labels (with halos) ---
    {name:"City labels xl", target:"text", layerPattern:/^City large scale\/x large( Halo)?$/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Bold",fontSize:16,tracking:10,fillText:C.noir,halo:true,haloColor:C.white,haloWeight:3.0}},
    {name:"City labels medium", target:"text", layerPattern:/^City large scale\/medium( Halo)?$/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Semibold",fontSize:12.5,tracking:8,fillText:C.noir,halo:true,haloColor:C.white,haloWeight:2.4}},
    {name:"POI labels", target:"text", layerPattern:/^Point of interest\/General( Halo)?$/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Regular",fontSize:9,fillText:C.poi,halo:true,haloColor:C.white,haloWeight:1.8}},

    {name:"Medical label", target:"text", layerPattern:/^Medical\/label\/Default( Halo)?$/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Semibold",fontSize:9,fillText:C.medical,halo:true,haloColor:C.white,haloWeight:1.8}},
    {name:"Education label", target:"text", layerPattern:/^Education\/label\/Default( Halo)?$/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Semibold",fontSize:9,fillText:C.education,halo:true,haloColor:C.white,haloWeight:1.8}},
    {name:"Retail label", target:"text", layerPattern:/^Retail\/label\/Default( Halo)?$/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Semibold",fontSize:9,fillText:C.retail,halo:true,haloColor:C.white,haloWeight:1.8}},
    {name:"Landmark label", target:"text", layerPattern:/^Landmark\/label\/Default( Halo)?$/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Semibold",fontSize:9,fillText:C.landmark,halo:true,haloColor:C.white,haloWeight:1.8}},
    {name:"Emergency label", target:"text", layerPattern:/^Emergency\/label\/Default( Halo)?$/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Semibold",fontSize:9,fillText:C.emergency,halo:true,haloColor:C.white,haloWeight:1.8}},
    {name:"Cemetery label", target:"text", layerPattern:/^Cemetery\/label\/Default( Halo)?$/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Regular",fontSize:9,fillText:C.cemetery,halo:true,haloColor:C.white,haloWeight:1.8}},
    {name:"Golf label", target:"text", layerPattern:/^Golf course\/label\/Default( Halo)?$/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Regular",fontSize:9,fillText:C.golf,halo:true,haloColor:C.white,haloWeight:1.8}},
    {name:"Industry label", target:"text", layerPattern:/^Industry\/label\/Default( Halo)?$/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Regular",fontSize:9,fillText:C.industry,halo:true,haloColor:C.white,haloWeight:1.8}},
    {name:"Transportation label", target:"text", layerPattern:/^Transportation\/label\/Default( Halo)?$/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Regular",fontSize:9,fillText:C.transport,halo:true,haloColor:C.white,haloWeight:1.8}},
    {name:"Military label", target:"text", layerPattern:/^Military\/label\/Default( Halo)?$/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Regular",fontSize:9,fillText:C.military,halo:true,haloColor:C.white,haloWeight:1.8}},

    // --- roads (geometry & tunnels) ---
    {name:"Freeway/Motorway 0", target:"path", layerPattern:/^Road( tunnel)?\/Freeway Motorway\/0$/i,
      style:{strokeColor:C.fwy, strokeWeight:1.9, strokeCap:StrokeCap.ROUNDENDCAP, strokeJoin:StrokeJoin.ROUNDENDJOIN}},
    {name:"Freeway/Motorway 1", target:"path", layerPattern:/^Road( tunnel)?\/Freeway Motorway\/1$/i,
      style:{strokeColor:C.fwy, strokeWeight:1.6, strokeCap:StrokeCap.ROUNDENDCAP, strokeJoin:StrokeJoin.ROUNDENDJOIN}},
    {name:"Freeway/Motorway 2", target:"path", layerPattern:/^Road( tunnel)?\/Freeway Motorway\/2$/i,
      style:{strokeColor:C.fwy, strokeWeight:1.3, strokeCap:StrokeCap.ROUNDENDCAP, strokeJoin:StrokeJoin.ROUNDENDJOIN}},

    {name:"Highway 0–2", target:"path", layerPattern:/^Road( tunnel)?\/Highway\/[0-2]$/i,
      style:{strokeColor:C.hwy, strokeWeight:1.3, strokeCap:StrokeCap.ROUNDENDCAP, strokeJoin:StrokeJoin.ROUNDENDJOIN}},
    {name:"Major 0–1", target:"path", layerPattern:/^Road( tunnel)?\/Major\/[0-1]$/i,
      style:{strokeColor:C.major, strokeWeight:1.1, strokeCap:StrokeCap.ROUNDENDCAP, strokeJoin:StrokeJoin.ROUNDENDJOIN}},
    {name:"Major ramps", target:"path", layerPattern:/^Road( tunnel)?\/Major, ramp or traffic circle\/[0-2]$/i,
      style:{strokeColor:C.major, strokeWeight:1.0, strokeDashes:[3,1.5], strokeCap:StrokeCap.ROUNDENDCAP, strokeJoin:StrokeJoin.ROUNDENDJOIN}},
    {name:"Minor 0–1", target:"path", layerPattern:/^Road( tunnel)?\/Minor\/[0-1]$/i,
      style:{strokeColor:C.minor, strokeWeight:0.9, strokeCap:StrokeCap.ROUNDENDCAP, strokeJoin:StrokeJoin.ROUNDENDJOIN}},
    {name:"Minor ramps", target:"path", layerPattern:/^Road( tunnel)?\/Minor, ramp or traffic circle\/[0-1]$/i,
      style:{strokeColor:C.minor, strokeWeight:0.85, strokeDashes:[2.5,1.3], strokeCap:StrokeCap.ROUNDENDCAP, strokeJoin:StrokeJoin.ROUNDENDJOIN}},
    {name:"Local/Service", target:"path", layerPattern:/^Road( tunnel)?\/(Local\/1|Service\/0)$/i,
      style:{strokeColor:C.local, strokeWeight:0.7, strokeCap:StrokeCap.ROUNDENDCAP, strokeJoin:StrokeJoin.ROUNDENDJOIN, opacity:85}},

    // --- rail/ferry/boundaries ---
    {name:"Railroad 0–2", target:"path", layerPattern:/^Railroad\/[0-2]$/i,
      style:{strokeColor:C.rail, strokeWeight:0.9, strokeDashes:[2.2,2.2]}},
    {name:"Ferry", target:"path", layerPattern:/^Ferry\/Ferry$/i,
      style:{strokeColor:C.ferry, strokeWeight:1.0, strokeDashes:[3,2]}},
    {name:"Boundary Admin1", target:"path", layerPattern:/^Boundary line\/Admin1\/[01]$/i,
      style:{strokeColor:C.bndry, strokeWeight:0.7, strokeDashes:[1.2,1.2], opacity:85}},

    // --- water ---
    {name:"Water line", target:"path", layerPattern:/^Water line(\/(Default|Stream or river))?$/i,
      style:{strokeColor:C.waterL, strokeWeight:0.9, strokeCap:StrokeCap.BUTTENDCAP, strokeJoin:StrokeJoin.ROUNDENDJOIN}},
    {name:"Water area lake/river/bay", target:"path", layerPattern:/^Water area\/Lake, river or bay$/i,
      style:{fillColor:C.waterA, forceFill:true, strokeColor:null}},
    {name:"Marine bathymetry 1", target:"path", layerPattern:/^Marine area\/bathymetry depth 1$/i,
      style:{fillColor:C.bathy, forceFill:true, strokeColor:null}},

    // --- landuse areas ---
    {name:"Park or farming", target:"path", layerPattern:/^Park or farming$/i,
      style:{fillColor:C.parkA, forceFill:true, strokeColor:null}},
    {name:"Medical area", target:"path", layerPattern:/^Medical$/i, style:{fillColor:C.medical, forceFill:true}},
    {name:"Education area", target:"path", layerPattern:/^Education$/i, style:{fillColor:C.education, forceFill:true}},
    {name:"Retail area", target:"path", layerPattern:/^Retail$/i, style:{fillColor:C.retail, forceFill:true}},
    {name:"Landmark area", target:"path", layerPattern:/^Landmark$/i, style:{fillColor:C.landmark, forceFill:true}},
    {name:"Emergency area", target:"path", layerPattern:/^Emergency$/i, style:{fillColor:C.emergency, forceFill:true}},
    {name:"Cemetery area", target:"path", layerPattern:/^Cemetery$/i, style:{fillColor:C.cemetery, forceFill:true}},
    {name:"Golf course area", target:"path", layerPattern:/^Golf course$/i, style:{fillColor:C.golf, forceFill:true}},
    {name:"Industry area", target:"path", layerPattern:/^Industry$/i, style:{fillColor:C.industry, forceFill:true}},
    {name:"Transportation area", target:"path", layerPattern:/^Transportation$/i, style:{fillColor:C.transport, forceFill:true}},
    {name:"Military area", target:"path", layerPattern:/^Military$/i, style:{fillColor:C.military, forceFill:true}},
    {name:"Admin0 forest/park", target:"path", layerPattern:/^Admin0 forest or park$/i, style:{fillColor:C.forest, forceFill:true}},
    {name:"Land/Not ice", target:"path", layerPattern:/^Land\/Not ice$/i, style:{fillColor:C.land, forceFill:true, strokeColor:null}},

    // --- VISIBLE FALLBACKS ---
    {name:"Any text (fallback)", target:"text", layerPattern:/.*/i,
      style:{fontFamily:"Source Sans Pro",fontStyle:"Regular",fontSize:9,fillText:C.noir,halo:true,haloColor:C.white,haloWeight:1.6}},
    {name:"Any path (fallback)", target:"path", layerPattern:/.*/i,
      style:{fillColor:rgb(255,255,0), forceFill:true, strokeColor:rgb(0,0,0), strokeWeight:1.2, opacity:100}}
  ];

  // ---------- progress palette ----------
  function Progress(title,max){
    var p=new Window('palette',title); p.alignChildren='fill';
    p.pbar=p.add('progressbar',undefined,0,Math.max(1,max||1));
    p.msg=p.add('statictext',undefined,'Starting…'); p.msg.characters=60; p.show();
    p.step=function(txt){ this.pbar.value++; if(txt) this.msg.text=txt; p.update(); };
    p.done=function(){ try{ this.close(); }catch(e){} };
    return p;
  }

  // ---------- collect EVERYTHING ----------
  var items=[];
  function visit(c){
    var i;
    // unlock / show container if possible
    try{ if ('locked' in c && c.locked) c.locked=false; }catch(e){}
    try{ if ('visible' in c && c.visible===false) c.visible=true; }catch(e){}
    for(i=0;i<c.groupItems.length;i++) visit(c.groupItems[i]);           // groups (incl. clip groups)
    for(i=0;i<c.pathItems.length;i++) items.push(c.pathItems[i]);        // paths
    for(i=0;i<c.compoundPathItems.length;i++) items.push(c.compoundPathItems[i]); // compound paths
    for(i=0;i<c.textFrames.length;i++) items.push(c.textFrames[i]);      // text
    // (symbols/plugins/graphs skipped for styling)
  }
  for (var L=0; L<doc.layers.length; L++){ visit(doc.layers[L]); }

  // ---------- ancestor handling ----------
  function unlockAndRevealChain(node){
    var hops=0;
    while(node && hops<40){
      try{ if ('locked' in node && node.locked) node.locked=false; }catch(e){}
      try{ if ('visible' in node && node.visible===false) node.visible=true; }catch(e){}
      node=node.parent; hops++;
    }
  }
  function nearestLayerName(item){
    var node=item, hops=0;
    while(node && hops<40){
      if (node.typename==="Layer") return node.name||"";
      node=node.parent; hops++;
    }
    // fallback
    try{ if (item.layer && item.layer.name) return item.layer.name; }catch(e){}
    return "";
  }

  // ---------- apply ----------
  function applyTextStyle(tf, style){
    try{
      var tr=tf.textRange, ca=tr.characterAttributes;
      var f=findTextFont(style.fontFamily||(ca.textFont?ca.textFont.family:null),
                         style.fontStyle||(ca.textFont?ca.textFont.style:null));
      if (f) ca.textFont=f;
      if (style.fontSize) ca.size=style.fontSize;
      if (style.tracking!==undefined) ca.tracking=style.tracking;
      if (style.fillText) ca.fillColor=style.fillText;
      if (style.halo){ ca.strokeColor=style.haloColor||C.white; ca.strokeWeight=style.haloWeight||1.6; ca.strokeOverPrint=false; }
    }catch(e){}
  }
  function applyPathStyle(item, style){
    try{
      if (item.typename==="CompoundPathItem"){ for (var i=0;i<item.pathItems.length;i++) applyPathStyle(item.pathItems[i],style); return; }
      if (style.forceFill && style.fillColor){ item.filled=true; item.fillColor=style.fillColor; }
      if (style.fillColor && item.filled) item.fillColor=style.fillColor;
      if (style.strokeColor===null){ item.stroked=false; }
      else if (style.strokeColor){ item.stroked=true; item.strokeColor=style.strokeColor; }
      if (style.strokeWeight!==undefined && item.stroked) item.strokeWidth=style.strokeWeight;
      if (style.strokeCap && item.stroked) item.strokeCap=style.strokeCap;
      if (style.strokeJoin && item.stroked) item.strokeJoin=style.strokeJoin;
      if (style.strokeDashes && item.stroked) item.strokeDashes=style.strokeDashes;
      if (style.opacity!==undefined) item.opacity=style.opacity;
    }catch(e){}
  }
  function matchRuleByLayerName(name, isText){
    var i,r;
    for(i=0;i<RULES.length;i++){
      r=RULES[i];
      if (r.target==="text" && !isText) continue;
      if (r.target==="path" && isText) continue;
      try{ if (r.layerPattern.test(name)) return r; }catch(e){}
    }
    return null;
  }

  // ---------- run ----------
  var p=Progress("FORCE v3 — styling…", items.length);
  var count={text:0, path:0, unmatched:0, rules:{}};

  for (var n=0;n<items.length;n++){
    var it=items[n];
    try{
      unlockAndRevealChain(it);
      var lname = nearestLayerName(it); // *** this is the sublayer name you see ***
      var isText = (it.typename==="TextFrame");
      var rule = matchRuleByLayerName(lname, isText);
      if (!rule){ count.unmatched++; p.step("…"); continue; }

      if (isText){ applyTextStyle(it, rule.style); count.text++; }
      else { applyPathStyle(it, rule.style); count.path++; }

      count.rules[rule.name]=(count.rules[rule.name]||0)+1;
      p.step(rule.name);
    }catch(e){ p.step("skip"); }
  }
  p.done();

  var lines=[];
  lines.push("DONE — "+items.length+" item(s) inspected.");
  lines.push("Text styled: "+count.text+" | Paths styled: "+count.path+" | Unmatched/Skipped: "+count.unmatched);
  lines.push("Rules hit:"); for (var k in count.rules) lines.push("  • "+k+" → "+count.rules[k]);
  alert(lines.join("\n"));
})();