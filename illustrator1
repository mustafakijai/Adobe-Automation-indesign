/**************************************************************
 * MapLayer_Styler_OMNI_v2.jsx
 * Author: ChatGPT for Mr Khan (Mustafa) — 2025
 * Adobe Illustrator CC 2019–2025 (macOS/Windows)
 *
 * WHAT IT DOES
 * • Lets you multi-select top-level layers (with optional sublayers) OR operate on current selection.
 * • Walks everything inside (TextFrames, PathItems, CompoundPathItems, Groups, Symbols).
 * • Applies powerful rule-based styling matched by layer name (RegExp) + item type.
 * • Map-friendly defaults: Road labels, Highways, Minor/Major, Water line/area, Parks, Railroads, Boundaries.
 * • Text: font family/style/size/tracking/fill + optional HALO (stroke on characters).
 * • Paths: fill, stroke, stroke weight, caps/joins, dash arrays, opacity, overprint.
 * • Robust options: skip/override lock & visibility, dry-run report, safe try/catch, progress UI.
 *
 * HOW TO CUSTOMIZE
 * • Edit RULES[] below — each rule has layerPattern (regex) + target ("text" | "path" | "any") and a style object.
 * • Fonts: set fontFamily and fontStyle; script falls back gracefully.
 * • Colors: use rgb(r,g,b) or cmyk(c,m,y,k). Illustrator will convert as needed.
 **************************************************************/

#target illustrator
(function () {
  if (app.documents.length === 0) { alert("Open a document first."); return; }
  var doc = app.activeDocument;

  // -------------------- UTIL: Colors --------------------
  function rgb(R, G, B) { var c = new RGBColor(); c.red = R; c.green = G; c.blue = B; return c; }
  function cmyk(C, M, Y, K) { var c = new CMYKColor(); c.cyan = C; c.magenta = M; c.yellow = Y; c.black = K; return c; }
  var COLORS = {
    black: rgb(20,20,20), white: rgb(255,255,255),
    roadMajor: rgb(60,60,60), roadMinor: rgb(110,110,110),
    waterLine: rgb(120,170,210), waterArea: rgb(185,215,240),
    parkArea: rgb(200,235,205), railroad: rgb(90,90,90),
    boundary: rgb(150,150,150)
  };

  // -------------------- DEFAULT FONT FALLBACK --------------------
  var FALLBACK_FONTS = ["SourceSansPro-Regular", "ArialMT", "Helvetica", "MyriadPro-Regular"];
  function findTextFont(family, style) {
    try {
      // Try exact family/style first
      for (var i=0; i<app.textFonts.length; i++) {
        var tf = app.textFonts[i];
        if (family && style) {
          if (tf.family === family && tf.style === style) return tf;
        } else if (family && tf.family === family) return tf;
      }
      // Fallback list
      for (var j=0; j<FALLBACK_FONTS.length; j++) {
        try { return app.textFonts.getByName(FALLBACK_FONTS[j]); } catch(e){}
      }
    } catch (e) {}
    // Last resort: first available
    return app.textFonts.length ? app.textFonts[0] : null;
  }

  // -------------------- STYLES & RULES --------------------
  // Style keys supported:
  //  fillColor, strokeColor, strokeWeight, strokeCap, strokeJoin, strokeDashes (array), opacity
  //  fontFamily, fontStyle, fontSize, tracking, fillText, halo (bool), haloColor, haloWeight
  //  forceStroke (bool), forceFill (bool)
  var RULES = [
    // ---- LABELS (Text) ----
    { name:"Highway labels", target:"text", layerPattern:/Road\/label\/.*Highway/i,
      style:{ fontFamily:"Source Sans Pro", fontStyle:"Semibold", fontSize:10.5, tracking:0,
              fillText: COLORS.black, halo:true, haloColor: COLORS.white, haloWeight:2.2 } },
    { name:"Major road labels", target:"text", layerPattern:/Road\/label\/Major/i,
      style:{ fontFamily:"Source Sans Pro", fontStyle:"Semibold", fontSize:9.5, tracking:0,
              fillText: COLORS.black, halo:true, haloColor: COLORS.white, haloWeight:1.8 } },
    { name:"Minor road labels", target:"text", layerPattern:/Road\/label\/Minor/i,
      style:{ fontFamily:"Source Sans Pro", fontStyle:"Regular", fontSize:8.5, tracking:0,
              fillText: rgb(50,50,50), halo:true, haloColor: COLORS.white, haloWeight:1.4 } },
    { name:"Local road labels", target:"text", layerPattern:/Road\/label\/Local/i,
      style:{ fontFamily:"Source Sans Pro", fontStyle:"Regular", fontSize:8, tracking:0,
              fillText: rgb(70,70,70), halo:true, haloColor: COLORS.white, haloWeight:1.2 } },
    { name:"City labels (large)", target:"text", layerPattern:/City large scale/i,
      style:{ fontFamily:"Source Sans Pro", fontStyle:"Bold", fontSize:14, tracking:10,
              fillText: COLORS.black, halo:true, haloColor: COLORS.white, haloWeight:2.5 } },
    { name:"POI labels", target:"text", layerPattern:/Point of interest/i,
      style:{ fontFamily:"Source Sans Pro", fontStyle:"Regular", fontSize:8.8, tracking:0,
              fillText: rgb(60,60,60), halo:true, haloColor: COLORS.white, haloWeight:1.2 } },

    // ---- LINEWORK (Paths) ----
    { name:"Water line", target:"path", layerPattern:/Water line/i,
      style:{ strokeColor: COLORS.waterLine, strokeWeight: 0.6, strokeCap: StrokeCap.BUTTENDCAP,
              strokeJoin: StrokeJoin.ROUNDENDJOIN, strokeDashes: [], opacity:100 } },
    { name:"Water area", target:"path", layerPattern:/Water area|bathymetry/i,
      style:{ fillColor: COLORS.waterArea, forceFill:true, strokeColor: null } },
    { name:"Parks & farming", target:"path", layerPattern:/Park|forest|farming/i,
      style:{ fillColor: COLORS.parkArea, forceFill:true, strokeColor: null } },
    { name:"Railroads", target:"path", layerPattern:/Railroad/i,
      style:{ strokeColor: COLORS.railroad, strokeWeight: 0.45, strokeDashes:[2,2],
              strokeCap: StrokeCap.BUTTENDCAP, strokeJoin: StrokeJoin.MITERENDJOIN, opacity:100 } },
    { name:"Boundaries", target:"path", layerPattern:/Boundary line/i,
      style:{ strokeColor: COLORS.boundary, strokeWeight: 0.35, strokeDashes:[1,1.5],
              strokeCap: StrokeCap.BUTTENDCAP, strokeJoin: StrokeJoin.MITERENDJOIN, opacity:85 } },

    // ---- FALLBACK CATCH-ALLS (keep last) ----
    { name:"Any text (fallback)", target:"text", layerPattern:/.*/i,
      style:{ fontFamily:"Source Sans Pro", fontStyle:"Regular", fontSize:9, tracking:0,
              fillText: rgb(35,35,35), halo:true, haloColor: COLORS.white, haloWeight:1.2 } },
    { name:"Any path (fallback)", target:"path", layerPattern:/.*/i,
      style:{ strokeColor: COLORS.roadMinor, strokeWeight: 0.25, strokeDashes: [] } }
  ];

  // -------------------- UI --------------------
  function buildUI() {
    var w = new Window('dialog', 'Map Layer Styler — OMNI v2');
    w.orientation = 'column'; w.alignChildren = 'fill';

    var info = w.add('group'); info.alignChildren='left';
    var lbl = info.add('statictext', undefined,
      (doc.selection.length ? "Mode: Selection ("+doc.selection.length+" items)." :
       "Mode: By Layer — choose one or more layers below."), {multiline:true});
    lbl.preferredSize.width = 520;

    var layerPanel = w.add('panel', undefined, 'Top-level Layers (multi-select)');
    layerPanel.alignChildren='fill';
    var list = layerPanel.add('listbox', undefined, [], {multiselect:true});
    list.preferredSize.height = 240;
    for (var i=0; i<doc.layers.length; i++) {
      var L = doc.layers[i];
      list.add('item', L.name + (L.visible ? '' : '  (hidden)') + (L.locked ? '  [locked]' : ''));
    }

    var opts = w.add('panel', undefined, 'Options');
    opts.alignChildren='left';
    var cbSub = opts.add('checkbox', undefined, 'Include sublayers'); cbSub.value = true;
    var cbUnlock = opts.add('checkbox', undefined, 'Temporarily unlock locked items'); cbUnlock.value = true;
    var cbHidden = opts.add('checkbox', undefined, 'Temporarily show hidden items'); cbHidden.value = true;
    var cbText = opts.add('checkbox', undefined, 'Process Text'); cbText.value = true;
    var cbPath = opts.add('checkbox', undefined, 'Process Paths (incl. compounds)'); cbPath.value = true;

    var btns = w.add('group'); btns.alignment='right';
    var dryBtn = btns.add('button', undefined, 'Dry Run');
    var okBtn = btns.add('button', undefined, 'Apply');
    var cancelBtn = btns.add('button', undefined, 'Cancel', {name:'cancel'});

    return {
      win:w, list:list, cbSub:cbSub, cbUnlock:cbUnlock, cbHidden:cbHidden, cbText:cbText, cbPath:cbPath,
      dryBtn:dryBtn, okBtn:okBtn, cancelBtn:cancelBtn
    };
  }

  // -------------------- PROGRESS UI --------------------
  function Progress(title, max) {
    var p = new Window('palette', title);
    p.alignChildren = 'fill';
    p.pbar = p.add('progressbar', undefined, 0, Math.max(1,max||1));
    p.msg  = p.add('statictext', undefined, 'Starting...'); p.msg.characters = 60;
    p.show();
    p.step = function (txt) { this.pbar.value++; if (txt) this.msg.text = txt; p.update(); };
    p.done = function () { try{ this.close(); }catch(e){} };
    return p;
  }

  // -------------------- WALKERS --------------------
  function collectFromLayer(L, includeSublayers, bag) {
    if (!L.visible && !ui.cbHidden.value) return;
    // Items directly in layer
    pushPageItems(L, bag);
    // Sublayers
    if (includeSublayers) {
      for (var i=0; i<L.layers.length; i++) collectFromLayer(L.layers[i], true, bag);
    }
  }
  function pushPageItems(container, bag) {
    // Groups
    for (var i=0; i<container.groupItems.length; i++) visitGroup(container.groupItems[i], bag);
    // PathItems
    for (var j=0; j<container.pathItems.length; j++) bag.push(container.pathItems[j]);
    // CompoundPaths
    for (var k=0; k<container.compoundPathItems.length; k++) bag.push(container.compoundPathItems[k]);
    // TextFrames
    for (var t=0; t<container.textFrames.length; t++) bag.push(container.textFrames[t]);
    // Symbols etc (optional)
    for (var s=0; s<container.symbolItems.length; s++) bag.push(container.symbolItems[s]);
    for (var p=0; p<container.pluginItems.length; p++) bag.push(container.pluginItems[p]);
    for (var e=0; e<container.graphItems.length; e++) bag.push(container.graphItems[e]);
  }
  function visitGroup(g, bag) {
    if (!g) return;
    for (var i=0; i<g.groupItems.length; i++) visitGroup(g.groupItems[i], bag);
    for (var j=0; j<g.pathItems.length; j++) bag.push(g.pathItems[j]);
    for (var k=0; k<g.compoundPathItems.length; k++) bag.push(g.compoundPathItems[k]);
    for (var t=0; t<g.textFrames.length; t++) bag.push(g.textFrames[t]);
    for (var s=0; s<g.symbolItems.length; s++) bag.push(g.symbolItems[s]);
  }

  // -------------------- APPLY STYLES --------------------
  function matchRule(layerName, item) {
    var isText = (item.typename === "TextFrame");
    var isPath = (item.typename === "PathItem" || item.typename === "CompoundPathItem");
    for (var i=0; i<RULES.length; i++) {
      var r = RULES[i];
      if (!r.layerPattern.test(layerName)) continue;
      if (r.target === "text" && !isText) continue;
      if (r.target === "path" && !isPath) continue;
      return r;
    }
    return null;
  }

  function applyTextStyle(tf, style) {
    try {
      var tr = tf.textRange;
      var ca = tr.characterAttributes;

      if (style.fontFamily || style.fontStyle) {
        var font = findTextFont(style.fontFamily || ca.textFont.family, style.fontStyle || ca.textFont.style);
        if (font) ca.textFont = font;
      }
      if (style.fontSize) ca.size = style.fontSize;
      if (style.tracking !== undefined) ca.tracking = style.tracking;

      if (style.fillText) ca.fillColor = style.fillText;

      if (style.halo) {
        ca.strokeColor = style.haloColor || rgb(255,255,255);
        ca.strokeWeight = style.haloWeight || 1.2;
        ca.strokeOverPrint = false;
      } else if (style.strokeColor) {
        ca.strokeColor = style.strokeColor;
        if (style.haloWeight) ca.strokeWeight = style.haloWeight;
      } else {
        // Optional: disable stroke
        // tf.textRange.characterAttributes.strokeColor = new NoColor();  // Illustrator doesn't expose NoColor directly
      }
    } catch(e){}
  }

  function applyPathStyle(item, style) {
    try {
      // If a CompoundPathItem, style its pathItems[0..n]
      if (item.typename === "CompoundPathItem") {
        for (var i=0;i<item.pathItems.length;i++) applyPathStyle(item.pathItems[i], style);
        return;
      }
      // Visibility/locking handled higher
      if (style.forceFill && style.fillColor) { item.filled = true; item.fillColor = style.fillColor; }
      if (style.fillColor && item.filled) item.fillColor = style.fillColor;

      if (style.strokeColor === null) { item.stroked = false; }
      else if (style.strokeColor) { item.stroked = true; item.strokeColor = style.strokeColor; }

      if (style.strokeWeight !== undefined && item.stroked) item.strokeWidth = style.strokeWeight;
      if (style.strokeCap && item.stroked) item.strokeCap = style.strokeCap;
      if (style.strokeJoin && item.stroked) item.strokeJoin = style.strokeJoin;
      if (style.strokeDashes && item.stroked) item.strokeDashes = style.strokeDashes;
      if (style.opacity !== undefined) item.opacity = style.opacity;
    } catch(e){}
  }

  // -------------------- RUN --------------------
  var ui = buildUI();

  function gatherTargetsFromUI() {
    var bag = [];
    if (doc.selection.length) {
      // Use selection
      for (var i=0; i<doc.selection.length; i++) bag.push(doc.selection[i]);
      return bag;
    }
    // Else, gather from selected layers in UI
    var chosen = [];
    for (var k=0; k<ui.list.selection?.length; k++) chosen.push(ui.list.selection[k].index);
    if (!chosen.length) { alert("Select one or more layers in the list, or select artwork and re-run."); return null; }

    var items = [];
    for (var x=0; x<chosen.length; x++) collectFromLayer(doc.layers[chosen[x]], ui.cbSub.value, items);
    return items;
  }

  function guardUnlock(item) {
    try {
      if (ui.cbUnlock.value && item.locked) item.locked = false;
      if (ui.cbHidden.value && item.hidden) item.hidden = false;
    } catch(e){}
  }

  function process(dryRun) {
    var targets = gatherTargetsFromUI();
    if (!targets) return;

    var count = { text:0, path:0, unmatched:0, rules:{} };
    var p = Progress(dryRun ? "Dry Run — scanning…" : "Styling…", targets.length);

    app.executeMenuCommand('doc-color'); // keeps engine awake

    for (var i=0; i<targets.length; i++) {
      var it = targets[i];
      try {
        guardUnlock(it);
        var layerName = (it.layer && it.layer.name) ? it.layer.name : (it.parent && it.parent.name ? it.parent.name : "");
        var rule = matchRule(layerName, it);

        if (!rule) { count.unmatched++; p.step("No rule: " + it.typename); continue; }

        var style = rule.style;
        if (it.typename === "TextFrame" && ui.cbText.value) { applyTextStyle(it, style); count.text++; }
        else if ((it.typename === "PathItem" || it.typename === "CompoundPathItem") && ui.cbPath.value) { applyPathStyle(it, style); count.path++; }
        else { count.unmatched++; }

        count.rules[rule.name] = (count.rules[rule.name]||0) + 1;
        p.step(rule.name);
      } catch (e) {
        p.step("Skipped (error)");
      }
    }
    p.done();

    // Report
    var lines = [];
    lines.push((dryRun ? "DRY RUN — " : "DONE — ") + targets.length + " item(s) inspected.");
    lines.push("Text styled: " + count.text + " | Paths styled: " + count.path + " | Unmatched/Skipped: " + count.unmatched);
    lines.push("Rules hit:");
    for (var k in count.rules) lines.push("  • " + k + " → " + count.rules[k]);
    alert(lines.join("\n"));
  }

  // Button wiring
  ui.dryBtn.onClick = function(){ process(true); };
  ui.okBtn.onClick  = function(){ process(false); ui.win.close(); };
  ui.cancelBtn.onClick = function(){ ui.win.close(); };
  ui.win.center(); ui.win.show();
})();