#target "indesign"
#targetengine "session"

/*
  INWIZ_Graph_TightFit.jsx
  • Fills current selection exactly (or 350×250 centered if none)
  • Stroke = None everywhere
  • Responsive labels: Source Sans Pro Light, 7pt × scale (cap-height baseline, tight fit)
  • Pie / Donut / Column / Bar (choose by const CHART_TYPE)
  • JLL palette (edit BASE)
*/

// ------------------ USER OPTIONS ------------------
var CHART_TYPE   = "Donut"; // "Pie", "Donut", "Column", "Bar"
var SHOW_VALUES  = true;    // numbers on bars/columns
var DONUT_INNER  = 55;      // % of radius for donut inner hole
var START_ANGLE  = -90;     // pie start (degrees)
var DATA_CSV = (
  ",Share\nRetail,35\nOffice,25\nHospitality,20\nIndustrial,20"
);
// Column/Bar demo:
/// DATA_CSV = ",Series A,Series B\nCat 1,10,20\nCat 2,30,25\nCat 3,22,17\nCat 4,18,34";

// Your JLL colors:
var BASE = [[167,143,129],[0,96,118],[72,145,163],[127,72,123],[90,162,104],[101,88,78],[188,117,121],[47,101,55],[174,117,169],[139,151,155]];
// --------------------------------------------------

(function () {
  if (!app.documents.length) { alert("Open a document first."); return; }
  var doc = app.activeDocument;

  // ---------- helpers ----------
  function TRIM(s){return String(s).replace(/^\s+|\s+$/g,"");}
  function none(){ try{ return doc.swatches.itemByName("None"); }catch(e){ return doc.swatches.item(2);} }
  function paper(){ try{ return doc.swatches.itemByName("Paper"); }catch(e){ return doc.swatches.item(0);} }
  function killStroke(o){ try{o.strokeWeight=0; o.strokeColor=none(); o.strokeTint=100;}catch(_){ } return o; }
  function deepNoStroke(g){ var it=g.allPageItems; for(var i=0;i<it.length;i++){ killStroke(it[i]); } killStroke(g); }
  function ensureLayer(){ try{ var L=doc.layers.itemByName("INWIZ Charts"); L.name; return L; }catch(e){ return doc.layers.add({name:"INWIZ Charts"}); } }
  function ensureColor(name,rgb){ try{ var c=doc.colors.itemByName(name); c.name; c.space=ColorSpace.RGB; c.model=ColorModel.PROCESS; c.colorValue=rgb; return c; }catch(e){ return doc.colors.add({name:name, space:ColorSpace.RGB, model:ColorModel.PROCESS, colorValue:rgb}); } }
  function palette(){ var a=[],i; for(i=0;i<BASE.length;i++) a.push(ensureColor("INWIZ-"+(i+1), BASE[i])); return a; }

  function activePage(){ var w=app.layoutWindows.length?app.layoutWindows[0]:null; return (w && w.activePage) ? w.activePage : doc.pages[0]; }
  function boundsFromSelection(){
    var s=app.selection;
    if(s.length && s[0].hasOwnProperty("geometricBounds")) return s[0].geometricBounds;
    // default 350×250 centered on page
    var pg=activePage().bounds, W=pg[3]-pg[1], H=pg[2]-pg[0], w=350, h=250, cx=(pg[1]+pg[3])/2, cy=(pg[0]+pg[2])/2;
    return [cy-h/2, cx-w/2, cy+h/2, cx+w/2];
  }
  function squareInside(b, pad){
    var t=b[0],l=b[1],bt=b[2],r=b[3],W=r-l,H=bt-t,S=Math.min(W,H)-2*pad, cx=(l+r)/2, cy=(t+bt)/2;
    if(S<2) S=2;
    return [cy-S/2, cx-S/2, cy+S/2, cx+S/2];
  }

  // ---------- text (responsive, tight) ----------
  function setSSP(tf, pt, just){
    try{ tf.texts[0].appliedFont="Source Sans Pro\tLight"; }
    catch(_){ try{ tf.texts[0].appliedFont="Source Sans Pro\tRegular"; }
      catch(__){ try{ tf.texts[0].appliedFont="Arial\tRegular"; }catch(___){} } }
    try{ tf.texts[0].pointSize=pt; }catch(_){}
    try{ tf.texts[0].justification= just || Justification.CENTER_ALIGN; }catch(_){}
    try{ tf.textFramePreferences.firstBaselineOffset = FirstBaseline.CAP_HEIGHT; }catch(_){}
    try{ tf.textFramePreferences.minimumFirstBaselineOffset = 0; }catch(_){}
    try{ tf.textFramePreferences.autoSizingType = AutoSizingTypeEnum.OFF; }catch(_){}
    try{ tf.parentStory.recompose(); }catch(_){}
    try{ tf.fit(FitOptions.FRAME_TO_CONTENT); }catch(_){}
    try{ tf.parentStory.recompose(); tf.fit(FitOptions.FRAME_TO_CONTENT); }catch(_){}
  }
  function centerLabel(parent, lay, x, y, text, pt, just){
    var tf = parent.textFrames.add(); tf.itemLayer=lay; killStroke(tf);
    tf.contents = text;
    tf.geometricBounds=[y-5, x-40, y+5, x+40];
    setSSP(tf, pt, just);
    var b=tf.geometricBounds, w=b[3]-b[1], h=b[2]-b[0];
    tf.geometricBounds=[y-h/2, x-w/2, y+h/2, x+w/2];
    return tf;
  }
  function leftLabel(parent, lay, xLeft, yCenter, text, pt){
    var tf = parent.textFrames.add(); tf.itemLayer=lay; killStroke(tf);
    tf.contents = text;
    tf.geometricBounds=[yCenter-5, xLeft, yCenter+5, xLeft+120];
    setSSP(tf, pt, Justification.LEFT_ALIGN);
    var b=tf.geometricBounds, w=b[3]-b[1], h=b[2]-b[0];
    tf.geometricBounds=[yCenter-h/2, xLeft, yCenter+h/2, xLeft+w];
    return tf;
  }

  // ---------- parse data ----------
  function csvToData(csv){
    var lines=String(csv||"").replace(/\r/g,"\n").split(/\n+/), rows=[], i;
    function split(line){ var p=String(line).split(/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/), k; for(k=0;k<p.length;k++) p[k]=p[k].replace(/^\"|\"$/g,"").replace(/\"\"/g,'"'); return p; }
    for(i=0;i<lines.length;i++){ var s=TRIM(lines[i]); if(s) rows.push(split(s)); }
    if(rows.length<2 || rows[0].length<2) throw Error("Need header + at least 1 row.");
    var names=rows[0].slice(1), cats=[], S=[], c,r,v;
    for(r=1;r<rows.length;r++) cats.push(rows[r][0]);
    for(c=1;c<rows[0].length;c++){ var col=[]; for(r=1;r<rows.length;r++){ v=parseFloat(TRIM(rows[r][c])); col.push(isNaN(v)?0:v); } S.push(col); }
    return {categories:cats, seriesNames:names, series:S};
  }

  // ---------- primitives ----------
  function addRect(p,lay,b){ var r=p.rectangles.add(); r.itemLayer=lay; if(b) r.geometricBounds=b; killStroke(r); return r; }
  function addPoly(p,lay){ var g=p.polygons.add(); g.itemLayer=lay; killStroke(g); return g; }
  function addOval(p,lay,b){ var o=p.ovals.add(); o.itemLayer=lay; if(b) o.geometricBounds=b; killStroke(o); return o; }

  // ---------- legend (kept small, inside top) ----------
  function legendRow(parent, lay, b, labels, sws, pt){
    if(!labels || !labels.length) return [];
    var t=b[0]+6, l=b[1]+6, x=l, y=t, gap=10, it=[];
    for(var i=0;i<labels.length;i++){
      var chip=addRect(parent,lay,[y, x, y+7, x+12]); chip.fillColor=sws[i%sws.length]; it.push(chip);
      var lab=leftLabel(parent,lay, x+14, y+3.5, labels[i], pt);
      it.push(lab);
      x = lab.geometricBounds[3] + gap;
      if(x > b[3]-60){ x=l; y += 12; } // wrap if too wide
    }
    return it;
  }

  // ---------- pie / donut ----------
  function arcPoints(cx,cy,r,a0,a1){
    var RAD=Math.PI/180, steps=Math.max(60, Math.round((a1-a0)/2)), pts=[[cx,cy]], k, ang;
    for(k=0;k<=steps;k++){ ang=a0+(a1-a0)*(k/steps); pts.push([cx+r*Math.cos(ang*RAD), cy+r*Math.sin(ang*RAD)]); }
    pts.push([cx,cy]); return pts;
  }
  function pieOrDonut(parent, lay, b, data, sws, asDonut, innerPct, startDeg, basePT){
    var t=b[0], l=b[1], bt=b[2], r=b[3], W=r-l, H=bt-t, minWH=Math.min(W,H);
    var pad=Math.max(4, minWH*0.02); // keep everything inside selection
    var sq=squareInside(b,pad);
    var cx=(sq[1]+sq[3])/2, cy=(sq[0]+sq[2])/2, R=(sq[3]-sq[1])/2;

    var cats=data.categories, S=data.series, vals=[], i,s;
    if(S.length===1){ vals=S[0].slice(0); } else { for(i=0;i<cats.length;i++){ var sum=0; for(s=0;s<S.length;s++) sum+=S[s][i]; vals.push(sum); } }
    var total=0; for(i=0;i<vals.length;i++) total+=Math.max(0,vals[i]); if(total<=0) total=1;

    var it=[], start=isNaN(startDeg)?-90:startDeg, end, pct, mid, lx, ly;
    // legend first (small, inside top)
    it = it.concat(legendRow(parent, lay, b, data.seriesNames, sws, basePT));

    for(i=0;i<vals.length;i++){
      pct=(vals[i]/total)*100; end=start+(pct/100)*360;
      var poly=addPoly(parent,lay); poly.paths[0].entirePath=arcPoints(cx,cy,R,start,end); poly.fillColor=sws[i%sws.length]; it.push(poly);

      // place label *inside* the slice (responsive)
      mid=(start+end)/2;
      var rLabel = (pct<8 ? R*0.78 : R*0.62); // very small slices further out
      lx=cx+rLabel*Math.cos(Math.PI/180*mid);
      ly=cy+rLabel*Math.sin(Math.PI/180*mid);
      it.push( centerLabel(parent,lay,lx,ly, (cats[i]||("Slice "+(i+1)))+" "+Math.round(pct)+"%", basePT, Justification.CENTER_ALIGN) );
      start=end;
    }

    if(asDonut){
      var rIn = R*(Math.max(5, Math.min(95, innerPct))/100);
      var hole = addOval(parent, lay, [cy-rIn, cx-rIn, cy+rIn, cx+rIn]); hole.fillColor=paper(); it.push(hole);
    }
    return it;
  }

  // ---------- column / bar (kept inside selection) ----------
  function niceMax(v){ if(v<=0) return 1; var p=Math.pow(10,Math.floor(Math.log(v)/Math.LN10)), n=Math.ceil(v/p), a=[1,2,5,10]; for(var i=0;i<a.length;i++) if(n<=a[i]) return a[i]*p; return 10*p; }
  function columns(parent, lay, b, data, sws, basePT){
    var t=b[0]+12, l=b[1]+10, bt=b[2]-16, r=b[3]-10, W=r-l, H=bt-t;
    var cats=data.categories, S=data.series, names=data.seriesNames, sCnt=S.length, cCnt=cats.length, max=0,i,s;
    for(s=0;s<sCnt;s++) for(i=0;i<cCnt;i++) if(S[s][i]>max) max=S[s][i]; max=niceMax(max);
    var it = it || []; it = legendRow(parent, lay, [b[0],b[1],t,b[3]], names, sws, basePT); // top legend
    var span=W/cCnt, clu=span*0.8, cw=(clu/sCnt)*0.9, left,x,h,off=Math.max(4, H*0.02);

    for(i=0;i<cCnt;i++){
      left=l+i*span+(span-clu)/2;
      for(s=0;s<sCnt;s++){
        h=(S[s][i]/max)*H; x=left+s*(clu/sCnt)+((clu/sCnt)-cw)/2;
        var rct=addRect(parent,lay,[bt-h, x, bt, x+cw]); rct.fillColor=sws[s%sws.length];
        if(SHOW_VALUES) it.push( centerLabel(parent,lay, x+cw/2, bt-h-off, String(S[s][i]), basePT, Justification.CENTER_ALIGN) );
      }
      it.push( centerLabel(parent,lay, left+clu/2, bt+8, String(cats[i]), basePT, Justification.CENTER_ALIGN) );
    }
    return it;
  }
  function bars(parent, lay, b, data, sws, basePT){
    var t=b[0]+12, l=b[1]+14, bt=b[2]-10, r=b[3]-14, W=r-l, H=bt-t;
    var cats=data.categories, S=data.series, names=data.seriesNames, sCnt=S.length, cCnt=cats.length, max=0,i,s;
    for(s=0;s<sCnt;s++) for(i=0;i<cCnt;i++) if(S[s][i]>max) max=S[s][i]; max=niceMax(max);
    var it = legendRow(parent, lay, [b[0],b[1],t,b[3]], names, sws, basePT);
    var span=H/cCnt, clu=span*0.8, bh=(clu/sCnt)*0.9, top,y0,w,off=Math.max(4, W*0.02);

    for(i=0;i<cCnt;i++){
      top=t+i*span+(span-clu)/2;
      for(s=0;s<sCnt;s++){
        w=(S[s][i]/max)*W; y0=top+s*(clu/sCnt)+((clu/sCnt)-bh)/2;
        var rct=addRect(parent,lay,[y0, l, y0+bh, l+w]); rct.fillColor=sws[s%sws.length];
        if(SHOW_VALUES) it.push( leftLabel(parent,lay, l+w+off, y0+bh/2, String(S[s][i]), basePT) );
      }
      // category label inside, flush right:
      var cat=leftLabel(parent,lay, r-4, top+clu/2, String(cats[i]), basePT);
      // nudge to the left so right edge stays inside
      var bb=cat.geometricBounds, wcat=bb[3]-bb[1]; cat.geometricBounds=[bb[0], r-4-wcat, bb[2], r-4];
      it.push(cat);
    }
    return it;
  }

  // ---------- build ----------
  var lay = ensureLayer(), sws = palette(), parent = activePage(), B = boundsFromSelection();
  var data;
  try { data = csvToData(DATA_CSV); } catch(e){ alert("Data error: "+e.message); return; }

  // responsive text size (7pt × scale, clamped 5–12)
  var W=B[3]-B[1], H=B[2]-B[0], scale=Math.min(W/350, H/250); if(!isFinite(scale)||scale<=0) scale=1;
  var BASE_PT = Math.max(5, Math.min(12, 7*scale));

  app.doScript(function(){
    var items=[];
    if(CHART_TYPE==="Pie"){
      items = pieOrDonut(parent, lay, B, data, sws, false, 0, START_ANGLE, BASE_PT);
    }else if(CHART_TYPE==="Donut"){
      items = pieOrDonut(parent, lay, B, data, sws, true, DONUT_INNER, START_ANGLE, BASE_PT);
    }else if(CHART_TYPE==="Column"){
      items = columns(parent, lay, B, data, sws, BASE_PT);
    }else if(CHART_TYPE==="Bar"){
      items = bars(parent, lay, B, data, sws, BASE_PT);
    }else{
      throw Error("Unknown CHART_TYPE: "+CHART_TYPE);
    }

    if(!items.length) throw Error("Nothing to draw.");
    var grp = parent.groups.add(items);
    grp.itemLayer = lay;
    grp.insertLabel("INWIZ_has","1");
    deepNoStroke(grp); // absolutely no strokes anywhere
  }, ScriptLanguage.JAVASCRIPT, undefined, UndoModes.ENTIRE_SCRIPT, "INWIZ Graph (TightFit)");
})();